LIBRARY ieee;
USE ieee.std_logic_1164.all;

-- The core of the Duke 550 processor
-- Author: <INSERT YOUR NAME HERE!!!!>

ENTITY processor IS
    PORT (	clock          : IN STD_LOGIC;
	         reset	         : IN STD_LOGIC;
			   keyboard_in	   : IN STD_LOGIC_VECTOR(31 downto 0);
			   keyboard_ack   : OUT STD_LOGIC;
				lcd_write	   : OUT STD_LOGIC;
			   lcd_data	      : OUT STD_LOGIC_VECTOR(31 downto 0) );
END processor;

ARCHITECTURE Structure OF processor IS
	COMPONENT imem IS
		PORT (	address	: IN STD_LOGIC_VECTOR (11 DOWNTO 0);
				   clken	   : IN STD_LOGIC ;
				   clock	   : IN STD_LOGIC ;
				   q	      : OUT STD_LOGIC_VECTOR (31 DOWNTO 0) );
	END COMPONENT;
	
	COMPONENT dmem IS
		PORT (	address	: IN STD_LOGIC_VECTOR (11 DOWNTO 0);
				   clock	   : IN STD_LOGIC ;
				   data	   : IN STD_LOGIC_VECTOR (31 DOWNTO 0);
				   wren	   : IN STD_LOGIC ;
				   q	      : OUT STD_LOGIC_VECTOR (31 DOWNTO 0) );
	END COMPONENT;
	
	COMPONENT regfile IS
		PORT (	clock, wren, clear	: IN STD_LOGIC;
				   regD, regA, regB	   : IN STD_LOGIC_VECTOR(4 DOWNTO 0);
				   valD	               : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
				   valA, valB	         : OUT STD_LOGIC_VECTOR(31 DOWNTO 0) );
	END COMPONENT;
	
	COMPONENT alu IS
		PORT (	A, B	      : IN STD_LOGIC_VECTOR(31 DOWNTO 0);	-- 32bit inputs
				   op	         : IN STD_LOGIC_VECTOR(2 DOWNTO 0);	-- 3bit ALU opcode
				   R	         : OUT STD_LOGIC_VECTOR(31 DOWNTO 0);	-- 32bit output
				   isEqual     : OUT STD_LOGIC; -- true if A=B
				   isLessThan	: OUT STD_LOGIC ); -- true if A<B
	END COMPONENT;
	
	COMPONENT control IS
	PORT (	op	    : IN STD_LOGIC_VECTOR(4 DOWNTO 0);	-- instruction opcode
			--TODO: Figure out what control signals you need here
			   BR     : OUT STD_LOGIC;
				JP     : OUT STD_LOGIC;
				ALUinB : OUT STD_LOGIC;
				ALUop  : OUT STD_LOGIC_VECTOR(2 downto 0);
				DMwe   : OUT STD_LOGIC;
				Rwe    : OUT STD_LOGIC;
				Rdst   : OUT STD_LOGIC;
				Rwd    : OUT STD_LOGIC;
				JR     : OUT STD_LOGIC;
				JAL    : OUT STD_LOGIC;
				BGT    : OUT STD_LOGIC;
		      Is_in  : OUT STD_LOGIC;	
			   Is_out : OUT STD_LOGIC 	
			);
	END COMPONENT;
	
	-- TODO: Likely need other components here (register/adder for PC?, muxes for the data path?, etc.) 
	COMPONENT mux IS
	GENERIC(n: integer);
	PORT (	A, B	: IN STD_LOGIC_VECTOR(n-1 DOWNTO 0);
			   s	: IN STD_LOGIC;	-- select (NOT A / B)
			   F	: OUT STD_LOGIC_VECTOR(n-1 DOWNTO 0) );
   END COMPONENT;
	
	COMPONENT lcd Is
   PORT (  clock,reset,write_en : in std_logic;
           data : in std_logic_vector(7 downto 0);
           lcd_data : out std_logic_vector(7 downto 0);
           lcd_rw,lcd_en,lcd_rs,lcd_on,lcd_blon : out std_logic
         );
   END COMPONENT;
	
	COMPONENT reg IS
	GENERIC ( n : integer := 12 );
	PORT (	D	: IN STD_LOGIC_VECTOR(n-1 DOWNTO 0);
			   clock, clear, enable	: IN STD_LOGIC;
			   Q	: OUT STD_LOGIC_VECTOR(n-1 DOWNTO 0) );
   END COMPONENT;
	
	COMPONENT adder_cs IS
	GENERIC(n: integer);
	PORT (	
		A, B : IN STD_LOGIC_VECTOR(n-1 DOWNTO 0);
		cin  : IN STD_LOGIC;
		cout : OUT STD_LOGIC;
		sum  : OUT STD_LOGIC_VECTOR(n-1 DOWNTO 0);
		signed_overflow : OUT STD_LOGIC	);
   END COMPONENT;
	-- TODO: Also likely need a bunch of signals...

	signal lcd_in: std_logic_vector(7 downto 0);
	signal lcd_out: std_logic_vector(7 downto 0);
	signal one : std_logic;
	signal zero : std_logic;
	signal ones: std_logic_vector(11 downto 0);
	signal clk_n : std_logic;
	
	signal rd : std_logic_vector(4 downto 0);
	signal rs : std_logic_vector(4 downto 0);
	signal rt : std_logic_vector(4 downto 0);
	signal r31 : std_logic_vector(4 downto 0);
	
	signal insn : std_logic_vector(31 downto 0);
	signal opcode : std_logic_vector(4 downto 0);
	signal target : std_logic_vector(26 downto 0);
	
	signal immd : std_logic_vector(16 downto 0);
	signal immd_extend : std_logic_vector(31 downto 0);
	
	signal reg_out_A : std_logic_vector(31 downto 0);
	signal reg_out_B : std_logic_vector(31 downto 0);
	signal dmem_out : std_logic_vector(31 downto 0);
	signal alu_out : std_logic_vector(31 downto 0);
	signal pc_out : std_logic_vector(11 downto 0);
	
	signal mux1_out : std_logic_vector(31 downto 0);
	signal mux2_out : std_logic_vector(31 downto 0);
	signal mux3_out : std_logic_vector(4 downto 0);
	signal mux4_out : std_logic_vector(4 downto 0);
	signal mux5_out : std_logic_vector(31 downto 0);
	signal mux6_out : std_logic_vector(31 downto 0);
	signal mux7_out : std_logic_vector(11 downto 0);
	signal mux8_out : std_logic_vector(11 downto 0);
	
	signal mux7_en : std_logic;
	
	signal eqzero : std_logic;
	signal less : std_logic;
	
	signal pc : std_logic_vector(11 downto 0);
	signal addone_12 : std_logic_vector(11 downto 0);
	signal addone_32 : std_logic_vector(31 downto 0);
	
	signal br_sig : std_logic;
	signal jp_sig : std_logic;
	signal aluinb_sig : std_logic;
	signal aluop_sig : std_logic_vector(2 downto 0);
	signal dmwe_sig : std_logic;
	signal rwe_sig : std_logic;
	signal rdst_sig : std_logic;
	signal rwd_sig : std_logic;
	signal jr_sig : std_logic;
	signal jal_sig : std_logic;
	signal bgt_sig : std_logic;
	signal is_in_sig: std_logic;
	signal is_out_sig: std_logic;
	
BEGIN
	-- TODO: Connect stuff up to make a processor
	
	---- FETCH Stage
	
	---- DECODE Stage
	
	---- EXECUTE Stage
	
	---- MEMORY WRITE Stage
	
	---- WRITEBACK Stage
   keyboard_ack<=is_in_sig;
	lcd_write<=is_out_sig;
	lcd_in<=reg_out_B(7 downto 0);
	lcd_data(7 downto 0)<=lcd_out;
	lcd_data(31 downto 8)<="000000000000000000000000";
	clk_n <=not(clock);
	
	opcode <= insn(31 downto 27);
	immd <= insn(16 downto 0);
	rd <= insn(26 downto 22);
	rs <= insn(21 downto 17);
	rt <= insn(16 downto 12);
	target <= insn(26 downto 0);
	
	mux7_en <= '1' when (((br_sig = '1') and (eqzero = '1')) or ((bgt_sig='1')and(less='1'))) else
	           '0';
	r31 <= "11111";
	
	immd_extend(31 downto 17)<= "000000000000000" when (immd(16)='0') else
	                            "111111111111111";
	immd_extend(16 downto 0) <= immd;
	
	addone_32(31 downto 12) <= "00000000000000000000";
	addone_32(11 downto 0) <= addone_12;
	
	one <= '1';
	zero<='0';
	ones <= "000000000001";

	
	
	Controller : control port map(
	         op =>	opcode,   
			   BR => br_sig,    
				JP => jp_sig,   
				ALUinB => aluinb_sig, 
				ALUop => aluop_sig,  
				DMwe => dmwe_sig,   
				Rwe => rwe_sig,   
				Rdst => rdst_sig,  
				Rwd => rwd_sig,   
				JR => jr_sig,     
				JAL => jal_sig,   
				BGT => bgt_sig,
		      Is_in => is_in_sig,
            Is_out => is_out_sig      		);
	
	RegisterFile : regfile port map(
	   clock => clk_n, 
		wren => rwe_sig,
		clear	=>reset,
		regD => mux4_out,
		regA => rs, 
		regB => mux3_out,
		valD => mux6_out,	
		valA => reg_out_A,
		valB => reg_out_B	  );
		
	InsnMem : imem port map(
	   address => pc,
		clken =>	one,
		clock => clock,
		q => insn );
		
	ALU_part : alu port map(
	   A => reg_out_A,
		B => mux1_out,	     
		op => aluop_sig,	       
		R => alu_out,	       
		isEqual => eqzero,   
		isLessThan => less	 ); 
		
	DataMem : dmem port map(
	   address => alu_out(11 downto 0),	
		clock => clock,
		data => reg_out_B,	  
		wren => dmwe_sig,
		q => dmem_out); 
	
	LCD_part : lcd port map(
	   clock =>clock,
		reset =>reset,
		write_en => is_out_sig,
      data => lcd_in,
      lcd_data => lcd_out
      --lcd_rw =>
		--lcd_en =>
		--lcd_rs =>
		--lcd_on =>
		--lcd_blon =>       
		);
	
	
	PC_part : reg generic map( n=> 12)
	port map(
	   D => pc,
	   clock => clock,
		clear => reset,
		enable => one,
		Q => pc_out );
	
	Adder : adder_cs generic map( n=> 12)
	port map(
	   A => ones,
		B => pc_out,
		cin  =>zero,
		--cout 
		sum  =>addone_12
		--signed_overflow 	
		);
		
	MUX1 : mux generic map( n=> 32)
	port map(
	   A => reg_out_B, 
		B => immd_extend,
		s => aluinb_sig,	
		F => mux1_out	);
		
	MUX2 : mux generic map( n=> 32)
	port map(
	   A => alu_out, 
		B => dmem_out,	
		s => rwd_sig,	
		F => mux2_out	);
		
	MUX3 : mux generic map( n=> 5)
	port map(
	   A => rd, 
		B => rt,
		s => rdst_sig,	
		F => mux3_out 	);
	
	MUX4 : mux generic map( n=> 5)
	port map(
	   A => rd, 
		B => r31,
		s => jal_sig,	
		F => mux4_out 	);
	
	MUX5 : mux generic map( n=> 32)
	port map(
	   A => mux2_out, 
		B => addone_32,
		s => jal_sig, 	
		F => mux5_out 	);
	
	MUX6 : mux generic map( n=> 32)
	port map(
	   A => mux5_out,
		B => keyboard_in,
		s => is_in_sig,	
		F => mux6_out 	);
	
	MUX7 : mux generic map( n=> 12)
	port map(
	   A => addone_12 , 
		B => immd_extend(11 downto 0),
		s => mux7_en, 	
		F => mux7_out 	);
	
	MUX8 : mux generic map( n=> 12)
	port map(
	   A => mux7_out, 
		B => target(11 downto 0),
		s => jp_sig,	
		F => mux8_out 	);
	
	MUX9 : mux generic map( n=> 12)
	port map(
	   A => mux8_out, 
		B => reg_out_B(11 downto 0), 
		s => jr_sig,	
		F => pc	);
	
	
		
END Structure;